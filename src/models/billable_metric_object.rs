/*
 * Lago API documentation
 *
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.17.1
 * Contact: tech@getlago.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct BillableMetricObject {
    /// Unique identifier of the billable metric created by Lago.
    #[serde(rename = "lago_id")]
    pub lago_id: uuid::Uuid,
    /// Name of the billable metric.
    #[serde(rename = "name")]
    pub name: String,
    /// Unique code used to identify the billable metric associated with the API request. This code associates each event with the correct metric.
    #[serde(rename = "code")]
    pub code: String,
    /// Internal description of the billable metric.
    #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Defines if the billable metric is persisted billing period over billing period.  - If set to `true`: the accumulated number of units calculated from the previous billing period is persisted to the next billing period. - If set to `false`: the accumulated number of units is reset to 0 at the end of the billing period. - If not defined in the request, default value is `false`.
    #[serde(rename = "recurring")]
    pub recurring: bool,
    /// Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are `round`, `ceil` and `floor`.
    #[serde(rename = "rounding_function", skip_serializing_if = "Option::is_none")]
    pub rounding_function: Option<RoundingFunction>,
    /// Specifies the number of decimal places to which the `rounding_function` will be rounded. It can be a positive or negative value.
    #[serde(rename = "rounding_precision", skip_serializing_if = "Option::is_none")]
    pub rounding_precision: Option<i32>,
    /// Creation date of the billable metric.
    #[serde(rename = "created_at")]
    pub created_at: String,
    /// Expression used to calculate the event units. The expression is evalutated for each event and the result is then used to calculate the total aggregated units.
    #[serde(rename = "expression", skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// Property of the billable metric used for aggregating usage data. This field is not required for `count_agg`.
    #[serde(rename = "field_name", skip_serializing_if = "Option::is_none")]
    pub field_name: Option<String>,
    /// Aggregation method used to compute usage for this billable metric.
    #[serde(rename = "aggregation_type")]
    pub aggregation_type: AggregationType,
    /// Parameter exclusively utilized in conjunction with the `weighted_sum` aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in `seconds`.
    #[serde(rename = "weighted_interval", skip_serializing_if = "Option::is_none")]
    pub weighted_interval: Option<WeightedInterval>,
    #[serde(rename = "filters", skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<models::BillableMetricFilterObject>>,
}

impl BillableMetricObject {
    pub fn new(lago_id: uuid::Uuid, name: String, code: String, recurring: bool, created_at: String, aggregation_type: AggregationType) -> BillableMetricObject {
        BillableMetricObject {
            lago_id,
            name,
            code,
            description: None,
            recurring,
            rounding_function: None,
            rounding_precision: None,
            created_at,
            expression: None,
            field_name: None,
            aggregation_type,
            weighted_interval: None,
            filters: None,
        }
    }
}
/// Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are `round`, `ceil` and `floor`.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RoundingFunction {
    #[serde(rename = "ceil")]
    Ceil,
    #[serde(rename = "floor")]
    Floor,
    #[serde(rename = "round")]
    Round,
}

impl Default for RoundingFunction {
    fn default() -> RoundingFunction {
        Self::Ceil
    }
}
/// Aggregation method used to compute usage for this billable metric.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum AggregationType {
    #[serde(rename = "count_agg")]
    CountAgg,
    #[serde(rename = "sum_agg")]
    SumAgg,
    #[serde(rename = "max_agg")]
    MaxAgg,
    #[serde(rename = "unique_count_agg")]
    UniqueCountAgg,
    #[serde(rename = "weighted_sum_agg")]
    WeightedSumAgg,
    #[serde(rename = "latest_agg")]
    LatestAgg,
}

impl Default for AggregationType {
    fn default() -> AggregationType {
        Self::CountAgg
    }
}
/// Parameter exclusively utilized in conjunction with the `weighted_sum` aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in `seconds`.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WeightedInterval {
    #[serde(rename = "seconds")]
    Seconds,
}

impl Default for WeightedInterval {
    fn default() -> WeightedInterval {
        Self::Seconds
    }
}

