/*
 * Lago API documentation
 *
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.17.1
 * Contact: tech@getlago.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`create_credit_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCreditNoteError {
    Status400(models::ApiErrorBadRequest),
    Status401(models::ApiErrorUnauthorized),
    Status422(models::ApiErrorUnprocessableEntity),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_credit_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadCreditNoteError {
    Status401(models::ApiErrorUnauthorized),
    Status404(models::ApiErrorNotFound),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`estimate_credit_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EstimateCreditNoteError {
    Status400(models::ApiErrorBadRequest),
    Status401(models::ApiErrorUnauthorized),
    Status422(models::ApiErrorUnprocessableEntity),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_all_credit_notes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindAllCreditNotesError {
    Status401(models::ApiErrorUnauthorized),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_credit_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindCreditNoteError {
    Status401(models::ApiErrorUnauthorized),
    Status404(models::ApiErrorNotFound),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_credit_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCreditNoteError {
    Status400(models::ApiErrorBadRequest),
    Status401(models::ApiErrorUnauthorized),
    Status404(models::ApiErrorNotFound),
    Status422(models::ApiErrorUnprocessableEntity),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`void_credit_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VoidCreditNoteError {
    Status401(models::ApiErrorUnauthorized),
    Status404(models::ApiErrorNotFound),
    Status405(models::ApiErrorNotAllowed),
    UnknownValue(serde_json::Value),
}


/// This endpoint creates a new credit note.
pub async fn create_credit_note(configuration: &configuration::Configuration, credit_note_create_input: models::CreditNoteCreateInput) -> Result<models::CreditNote, Error<CreateCreditNoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/credit_notes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&credit_note_create_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateCreditNoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint downloads the PDF of an existing credit note.
pub async fn download_credit_note(configuration: &configuration::Configuration, lago_id: &str) -> Result<models::CreditNote, Error<DownloadCreditNoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/credit_notes/{lago_id}/download", local_var_configuration.base_path, lago_id=crate::apis::urlencode(lago_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DownloadCreditNoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to retrieve amounts for a new credit note creation.
pub async fn estimate_credit_note(configuration: &configuration::Configuration, credit_note_estimate_input: Option<models::CreditNoteEstimateInput>) -> Result<models::CreditNoteEstimated, Error<EstimateCreditNoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/credit_notes/estimate", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&credit_note_estimate_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EstimateCreditNoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint list all existing credit notes.
pub async fn find_all_credit_notes(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>, external_customer_id: Option<&str>, issuing_date_from: Option<String>, issuing_date_to: Option<String>, search_term: Option<&str>, currency: Option<&str>, reason: Option<&str>, credit_status: Option<&str>, refund_status: Option<&str>, invoice_number: Option<&str>, amount_from: Option<i32>, amount_to: Option<i32>) -> Result<models::CreditNotes, Error<FindAllCreditNotesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/credit_notes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = external_customer_id {
        local_var_req_builder = local_var_req_builder.query(&[("external_customer_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = issuing_date_from {
        local_var_req_builder = local_var_req_builder.query(&[("issuing_date_from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = issuing_date_to {
        local_var_req_builder = local_var_req_builder.query(&[("issuing_date_to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search_term {
        local_var_req_builder = local_var_req_builder.query(&[("search_term", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency {
        local_var_req_builder = local_var_req_builder.query(&[("currency", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = reason {
        local_var_req_builder = local_var_req_builder.query(&[("reason", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = credit_status {
        local_var_req_builder = local_var_req_builder.query(&[("credit_status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = refund_status {
        local_var_req_builder = local_var_req_builder.query(&[("refund_status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = invoice_number {
        local_var_req_builder = local_var_req_builder.query(&[("invoice_number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = amount_from {
        local_var_req_builder = local_var_req_builder.query(&[("amount_from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = amount_to {
        local_var_req_builder = local_var_req_builder.query(&[("amount_to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FindAllCreditNotesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint retrieves an existing credit note.
pub async fn find_credit_note(configuration: &configuration::Configuration, lago_id: &str) -> Result<models::CreditNote, Error<FindCreditNoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/credit_notes/{lago_id}", local_var_configuration.base_path, lago_id=crate::apis::urlencode(lago_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FindCreditNoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint updates an existing credit note.
pub async fn update_credit_note(configuration: &configuration::Configuration, lago_id: &str, credit_note_update_input: models::CreditNoteUpdateInput) -> Result<models::CreditNote, Error<UpdateCreditNoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/credit_notes/{lago_id}", local_var_configuration.base_path, lago_id=crate::apis::urlencode(lago_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&credit_note_update_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateCreditNoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint voids the available credit linked to a specific credit note.
pub async fn void_credit_note(configuration: &configuration::Configuration, lago_id: &str) -> Result<models::CreditNote, Error<VoidCreditNoteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/credit_notes/{lago_id}/void", local_var_configuration.base_path, lago_id=crate::apis::urlencode(lago_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VoidCreditNoteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

